<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Simulation (Fix Texture Loading & Debug Orbit)</title> <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
            touch-action: none;
         }
         /* --- UI Styling --- */
         .ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            color: white;
            max-width: 180px;
         }
         #choosePlanetBtn {
             padding: 8px 15px; cursor: pointer; background-color: rgba(255, 255, 255, 0.2);
             color: white; border: 1px solid rgba(255, 255, 255, 0.5); border-radius: 5px;
             margin-bottom: 5px;
             width: 100%;
             box-sizing: border-box;
         }
         #choosePlanetBtn:hover { background-color: rgba(255, 255, 255, 0.4); }

         #planetListDropdown {
            display: none;
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 5px;
            padding: 5px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 5px;
         }
          #planetListDropdown button {
            display: block; width: 100%; padding: 5px 10px; margin-bottom: 3px;
            cursor: pointer; background-color: rgba(255, 255, 255, 0.1); color: white;
            border: none; border-radius: 3px; text-align: left; font-size: 0.9em;
            box-sizing: border-box;
         }
         #planetListDropdown button:hover { background-color: rgba(255, 255, 255, 0.3); }
         #planetListDropdown button:last-child { margin-bottom: 0; }

         #distanceControl {
            display: none;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
         }
         #distanceControl label { display: block; margin-bottom: 5px; font-size: 0.9em; }
         #distanceSlider { width: 100%; cursor: pointer; box-sizing: border-box; }
         #distanceValue { margin-left: 5px; font-size: 0.9em; }

    </style>
</head>
<body>
    <div class="ui-container">
        <button id="choosePlanetBtn">Choose Planet</button>
        <div id="planetListDropdown">
            <button data-name="Background">Reset Focus</button>
        </div>
        <div id="distanceControl">
            <label for="distanceSlider">Distance: <span id="distanceValue">N/A</span></label>
            <input type="range" id="distanceSlider" min="3" max="50" value="10" step="0.1">
        </div>
    </div>

    <canvas id="webgl-canvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        const textureLoader = new THREE.TextureLoader();
        const clock = new THREE.Clock();
        const planets = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let clickableObjects = [];
        let moonMesh; // Keep separate ref for potential specific logic
        let targetObject = null;
        const targetPositionVec = new THREE.Vector3();
        const cameraOffsetDir = new THREE.Vector3();
        let desiredDistance = 10.0;
        const desiredCameraPosition = new THREE.Vector3();
        let loadingSphere = null;
        const texturesMap = new Map(); // --- Store loaded textures ---

        // --- UI Elements ---
        const choosePlanetBtn = document.getElementById('choosePlanetBtn');
        const planetListDropdown = document.getElementById('planetListDropdown');
        const distanceControl = document.getElementById('distanceControl');
        const distanceSlider = document.getElementById('distanceSlider');
        const distanceValueLabel = document.getElementById('distanceValue');

        // --- Base URL for textures ---
        const baseURL = "https://raw.githubusercontent.com/DragonLord1998/Terra/main/";

        // --- Texture Files ---
        // Define all texture files needed, mapping keys to filenames
        const textureFiles = {
            starfield: "8k_stars_milky_way.jpg",
            saturnRing: "8k_saturn_ring_alpha.png",
            sun: "8k_sun.jpg",
            mercury: "8k_mercury.jpg",
            venus: "8k_venus_surface.jpg",
            earth: "earth_day.jpg",
            earthClouds: "earth_clouds.jpg",
            mars: "8k_mars.jpg",
            jupiter: "8k_jupiter.jpg",
            saturn: "8k_saturn.jpg",
            uranus: "2k_uranus.jpg",
            neptune: "2k_neptune.jpg",
            moon: "8k_moon.jpg"
            // Add other maps here if needed later (normal, specular etc.)
            // e.g., earthNormal: "2k_earth_normal_map.png"
        };

        // --- Planet Data (References textureFiles keys) ---
        const solarSystemData = [
            { name: "Mercury", textureKey: "mercury", radius: 0.38, distance: 6, orbitSpeed: 0.04, rotationSpeed: 0.01, tilt: 0.03, fallbackColor: 0xAAAAAA },
            { name: "Venus", textureKey: "venus", radius: 0.95, distance: 9, orbitSpeed: 0.02, rotationSpeed: 0.005, tilt: 177.4, fallbackColor: 0xD4BF9A },
            { name: "Earth", textureKey: "earth", radius: 1.0, distance: 13, orbitSpeed: 0.01, rotationSpeed: 0.02, tilt: 23.4, moon: true, cloudsKey: "earthClouds", fallbackColor: 0x4B91E3 },
            { name: "Mars", textureKey: "mars", radius: 0.53, distance: 18, orbitSpeed: 0.008, rotationSpeed: 0.018, tilt: 25.2, fallbackColor: 0xC1440E },
            { name: "Jupiter", textureKey: "jupiter", radius: 3.5, distance: 28, orbitSpeed: 0.004, rotationSpeed: 0.04, tilt: 3.1, fallbackColor: 0xD8CAAD },
            { name: "Saturn", textureKey: "saturn", radius: 3.0, distance: 40, orbitSpeed: 0.003, rotationSpeed: 0.038, tilt: 26.7, rings: true, ringsTextureKey: "saturnRing", fallbackColor: 0xE0D8C0 },
            { name: "Uranus", textureKey: "uranus", radius: 2.0, distance: 55, orbitSpeed: 0.002, rotationSpeed: 0.03, tilt: 97.8, fallbackColor: 0xAFDBF5 },
            { name: "Neptune", textureKey: "neptune", radius: 1.9, distance: 70, orbitSpeed: 0.001, rotationSpeed: 0.028, tilt: 28.3, fallbackColor: 0x5B5DDF }
        ];
        const sunData = { name: "Sun", textureKey: "sun", radius: 3.5, fallbackColor: 0xFFFF00 };
        const moonData = { name: "Moon", textureKey: "moon", fallbackColor: 0xCCCCCC, tilt: 6.7 };


        // --- Focus Function ---
        function focusOnObject(objectMesh) {
            if (!objectMesh || !controls || !camera) return;
            console.log("Focusing on:", objectMesh.userData.name);
            targetObject = objectMesh;
            targetObject.getWorldPosition(targetPositionVec);
            const initialDistance = Math.max(5, camera.position.distanceTo(targetPositionVec));
            cameraOffsetDir.subVectors(camera.position, targetPositionVec).normalize();
            desiredDistance = initialDistance;
            console.log("Set target direction:", cameraOffsetDir);
            console.log("Set initial distance:", initialDistance);
            distanceSlider.value = desiredDistance;
            distanceSlider.min = (objectMesh.geometry?.parameters?.radius || 1) * 2.5;
            distanceSlider.max = Math.max(50, initialDistance * 2);
            distanceValueLabel.textContent = desiredDistance.toFixed(1);
            distanceControl.style.display = 'block';
            controls.target.copy(targetPositionVec);
        }

        // --- Reset Focus Function ---
        function resetFocus() {
             console.log("Resetting focus");
             targetObject = null;
             controls.target.set(0, 0, 0);
             distanceControl.style.display = 'none';
        }

         // --- Window Resize Handler ---
        function onWindowResize() {
             if (camera && renderer) {
                 camera.aspect = window.innerWidth / window.innerHeight;
                 camera.updateProjectionMatrix();
                 renderer.setSize(window.innerWidth, window.innerHeight);
             }
        }


        // --- Initialization Function ---
        async function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();

            // 2. Camera Setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 80);

            // 3. Renderer Setup
            const canvas = document.getElementById('webgl-canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;

            // 4. Orbit Controls Setup
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05;
            controls.maxDistance = 400;

            // 5. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const sunLight = new THREE.PointLight(0xffffff, 6.0);
            sunLight.position.set(0, 0, 0);
            scene.add(sunLight);


            // --- Create and add Loading Sphere ---
            const loadingGeo = new THREE.SphereGeometry(1, 32, 16);
            const loadingMat = new THREE.MeshBasicMaterial({ color: 0x0077ff });
            loadingSphere = new THREE.Mesh(loadingGeo, loadingMat);
            scene.add(loadingSphere);
            console.log("Loading indicator added.");


            // --- Load ALL Textures Upfront ---
            console.log("Starting texture loading...");
            const textureLoadPromises = [];
            const textureKeys = Object.keys(textureFiles);

            for (const key of textureKeys) {
                 const url = baseURL + textureFiles[key];
                 const isColorData = !(key === 'saturnRing'); // Treat only ring alpha as non-color for now
                 textureLoadPromises.push(
                     textureLoader.loadAsync(url)
                         .then(texture => {
                             if (isColorData) { texture.colorSpace = THREE.SRGBColorSpace; }
                             texturesMap.set(key, texture); // Store in Map
                             console.log(`Texture loaded: ${key}`);
                         })
                         .catch(error => {
                             console.error(`Failed to load texture: ${key} (${url})`, error);
                             texturesMap.set(key, null); // Store null on failure
                         })
                 );
            }
            await Promise.all(textureLoadPromises);
            console.log("Texture loading finished.");
            // --- End Texture Loading ---


            // --- Remove Loading Sphere ---
            if (loadingSphere) {
                 console.log("Removing loading indicator.");
                 scene.remove(loadingSphere);
                 loadingSphere.geometry.dispose(); loadingSphere.material.dispose(); loadingSphere = null;
            }

            // --- Create Starfield Background ---
            const starfieldTexture = texturesMap.get('starfield');
            if (starfieldTexture) {
                 const starfieldGeometry = new THREE.SphereGeometry(500, 64, 32);
                 const starfieldMaterial = new THREE.MeshBasicMaterial({ map: starfieldTexture, side: THREE.BackSide });
                 const starfieldMesh = new THREE.Mesh(starfieldGeometry, starfieldMaterial);
                 scene.add(starfieldMesh);
             } else { scene.background = new THREE.Color(0x000000); }


            // --- Create Sun ---
            const sunTexture = texturesMap.get(sunData.textureKey); // Get from Map
            const sunGeometry = new THREE.SphereGeometry(sunData.radius, 64, 32);
            let sunMaterial;
            if (sunTexture) { sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture, emissive: 0xFFFFDD, emissiveIntensity: 1.1 }); }
            else { console.warn(`Using fallback color for Sun`); sunMaterial = new THREE.MeshBasicMaterial({ color: sunData.fallbackColor }); }
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.userData = { name: "Sun", isCelestialBody: true };
            scene.add(sunMesh);
            clickableObjects.push(sunMesh);

            // --- Add Sun Corona ---
            const coronaGeometry = new THREE.SphereGeometry(sunData.radius * 1.15, 64, 32);
            const coronaMaterial = new THREE.MeshBasicMaterial({ color: 0xffccaa, transparent: true, opacity: 0.25, blending: THREE.AdditiveBlending, depthWrite: false });
            const coronaMesh = new THREE.Mesh(coronaGeometry, coronaMaterial);
            scene.add(coronaMesh);


            // --- Create Planets & Populate Dropdown ---
            const dropdownContent = planetListDropdown;
            dropdownContent.innerHTML = '<button data-name="Background">Reset Focus</button>';
            const sunButton = document.createElement('button');
            sunButton.textContent = sunData.name; sunButton.dataset.name = sunData.name;
            dropdownContent.appendChild(sunButton);

            for (const data of solarSystemData) {
                const planetTexture = texturesMap.get(data.textureKey); // Get from Map
                const planetGeometry = new THREE.SphereGeometry(data.radius, 64, 32); // Use 64x32 segments
                let planetMaterial;
                if (planetTexture) { planetMaterial = new THREE.MeshStandardMaterial({ map: planetTexture, roughness: 0.8, metalness: 0.1 }); }
                else { console.warn(`Using fallback color for ${data.name}`); planetMaterial = new THREE.MeshStandardMaterial({ color: data.fallbackColor, roughness: 0.8, metalness: 0.1 }); }
                const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
                planetMesh.userData = { name: data.name, isCelestialBody: true };

                if (data.tilt !== undefined) { planetMesh.rotation.z = THREE.MathUtils.degToRad(data.tilt); }

                clickableObjects.push(planetMesh);
                const pivot = new THREE.Object3D(); scene.add(pivot); pivot.add(planetMesh);
                planetMesh.position.set(data.distance, 0, 0);

                // --- Make sure planetData includes pivot ---
                const planetData = {
                    name: data.name,
                    mesh: planetMesh,
                    pivot: pivot, // Ensure pivot is included
                    orbitSpeed: data.orbitSpeed,
                    rotationSpeed: data.rotationSpeed
                };

                // Add clouds
                if (data.cloudsKey) {
                    const cloudTexture = texturesMap.get(data.cloudsKey); // Get from Map
                    if (cloudTexture) {
                         const cloudGeometry = new THREE.SphereGeometry(data.radius * 1.01, 64, 32);
                         const cloudMaterial = new THREE.MeshBasicMaterial({ map: cloudTexture, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending });
                         const cloudMesh = new THREE.Mesh(cloudGeometry, cloudMaterial);
                         planetMesh.add(cloudMesh);
                         planetData.cloudMesh = cloudMesh;
                    } else { console.warn(`Skipping clouds for ${data.name}...`); }
                 }
                // Add Moon
                if (data.moon) {
                    const moonTexture = texturesMap.get(moonData.textureKey); // Get from Map
                    const moonRadius = data.radius * 0.27; const moonDistance = data.radius + 1.0;
                    const moonGeometry = new THREE.SphereGeometry(moonRadius, 32, 16);
                    let moonMaterial;
                    if (moonTexture) { moonMaterial = new THREE.MeshStandardMaterial({ map: moonTexture, roughness: 0.9 }); }
                    else { console.warn(`Using fallback color for Moon`); moonMaterial = new THREE.MeshStandardMaterial({ color: moonData.fallbackColor, roughness: 0.9 }); }
                    moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
                    moonMesh.userData = { name: "Moon", isCelestialBody: true };
                    if (moonData.tilt !== undefined) { moonMesh.rotation.z = THREE.MathUtils.degToRad(moonData.tilt); }
                    clickableObjects.push(moonMesh);
                    const moonPivot = new THREE.Object3D(); planetMesh.add(moonPivot); moonPivot.add(moonMesh);
                    moonMesh.position.set(moonDistance, 0, 0);
                    planetData.moonPivot = moonPivot;
                    planetData.moonOrbitSpeed = data.orbitSpeed * 10;
                }
                // Add Rings
                if (data.rings) {
                    const ringTexture = texturesMap.get(data.ringsTextureKey); // Get from Map
                    const innerRadius = data.radius * 1.2; const outerRadius = data.radius * 2.2;
                    const ringGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 64);
                    const pos = ringGeometry.attributes.position; const v3 = new THREE.Vector3();
                    for (let i = 0; i < pos.count; i++){ v3.fromBufferAttribute(pos, i); pos.setXYZ(i, v3.x, 0, v3.y); }
                    ringGeometry.attributes.position.needsUpdate = true; ringGeometry.computeVertexNormals();
                    let ringMaterial;
                    if (ringTexture) { ringMaterial = new THREE.MeshBasicMaterial({ map: ringTexture, side: THREE.DoubleSide, transparent: true }); }
                    else { ringMaterial = new THREE.MeshBasicMaterial({ color: 0xAAAAAA, side: THREE.DoubleSide, transparent: true, opacity: 0.6 }); }
                    const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                    ringMesh.rotation.x = Math.PI * 0.45;
                    planetMesh.add(ringMesh);
                 }
                planets.push(planetData);

                // Add button to Dropdown
                const button = document.createElement('button');
                button.textContent = data.name; button.dataset.name = data.name;
                dropdownContent.appendChild(button);
             }
             // Add Moon button to dropdown
             if (moonMesh) {
                  const button = document.createElement('button');
                  button.textContent = moonData.name; button.dataset.name = moonData.name;
                  dropdownContent.appendChild(button);
             }


            // --- Add Event Listeners ---
            renderer.domElement.addEventListener('pointerdown', onPointerDownViaRaycast, false);
            choosePlanetBtn.addEventListener('click', (event) => {
                 event.stopPropagation();
                 planetListDropdown.style.display = planetListDropdown.style.display === 'block' ? 'none' : 'block';
            });
            planetListDropdown.addEventListener('click', onUIPanelClick);
            distanceSlider.addEventListener('input', (event) => {
                 desiredDistance = parseFloat(event.target.value);
                 distanceValueLabel.textContent = desiredDistance.toFixed(1);
            });
            document.addEventListener('click', (event) => {
                 if (!choosePlanetBtn.parentElement.contains(event.target)) {
                    planetListDropdown.style.display = 'none';
                }
            });


            // Handle Window Resizing
            window.addEventListener('resize', onWindowResize);
        }

        // --- Pointer Down Handler (Raycasting) ---
        function onPointerDownViaRaycast(event) { /* ... */ }

        // --- UI Panel Click Handler ---
        function onUIPanelClick(event) { /* ... */ }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (loadingSphere) {
                 loadingSphere.rotation.y += delta * 0.5; loadingSphere.rotation.x += delta * 0.3;
            } else if (planets.length > 0) {
                planets.forEach(p => {
                    if (p.pivot) {
                        p.pivot.rotation.y += p.orbitSpeed * delta * 10; // Orbit
                    }
                    if (p.mesh) {
                         p.mesh.rotateY(p.rotationSpeed * delta * 10); // Self-rotation on local Y
                    }
                    if (p.cloudMesh) { p.cloudMesh.rotateY(p.rotationSpeed * 1.1 * delta * 10); }
                    if (p.moonPivot) {
                        p.moonPivot.rotation.y += p.moonOrbitSpeed * delta * 10; // Moon orbit
                        if (moonMesh) { moonMesh.rotateY(p.rotationSpeed * delta * 5); } // Moon self-rotation
                    }
                });
                // Camera follow logic
                if (targetObject) {
                    targetObject.getWorldPosition(targetPositionVec);
                    controls.target.copy(targetPositionVec);
                    desiredCameraPosition.copy(targetPositionVec).addScaledVector(cameraOffsetDir, desiredDistance);
                    camera.position.copy(desiredCameraPosition);
                }
            }

            if (controls) { controls.update(); }
            if (renderer && scene && camera) { renderer.render(scene, camera); }
        }

        // --- Start animation loop FIRST ---
        animate();
        // --- Then start async initialization ---
        init().catch(error => { console.error("Initialization failed:", error); });

    </script>
</body>
</html>
